{% extends "base.html" %}
{% block content %}
<style>
  .custom-container {
    max-width: 1400px;
    margin: 20px auto;
    padding: 20px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 12px;
    color: #e0e0e0;
    font-size: 1.1rem;
  }
  
  .section-title {
    font-size: 1.8rem;
    margin: 20px 0 10px;
    color: #1e90ff;
    border-bottom: 2px solid #1e90ff;
    padding-bottom: 5px;
  }
  
  .layer-card {
    background: rgba(30, 30, 30, 0.9);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 20px;
    margin: 15px 0;
    position: relative;
  }
  
  .layer-card h4 {
    margin: 0 0 15px 0;
    color: #1e90ff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.5rem;
    font-weight: 600;
  }
  
  .remove-layer {
    background: #dc3545;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: 500;
  }
  
  .remove-layer:hover {
    background: #c82333;
  }
  
  .form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    margin-bottom: 15px;
  }
  
  .form-group {
    display: flex;
    flex-direction: column;
  }
  
  .form-group label {
    font-size: 1.15rem;
    margin-bottom: 8px;
    color: #ccc;
    cursor: help;
    font-weight: 500;
  }
  
  .form-group input, .form-group select {
    padding: 12px;
    border: 1px solid #555;
    border-radius: 4px;
    background: #222;
    color: #e0e0e0;
    font-size: 1.15rem;
  }
  
  .form-group input:focus, .form-group select:focus {
    outline: none;
    border-color: #1e90ff;
  }
  
  .btn-primary {
    background: #1e90ff;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.15rem;
    margin: 5px;
  }
  
  .btn-primary:hover {
    background: #1c7ed6;
  }
  
  .btn-secondary {
    background: #555;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.15rem;
    margin: 5px;
  }
  
  .btn-secondary:hover {
    background: #666;
  }
  
  .results-panel {
    margin-top: 20px;
    padding: 15px;
    background: rgba(40, 40, 40, 0.95);
    border-radius: 8px;
    display: none;
  }
  
  .metric-card {
    display: inline-block;
    padding: 15px 25px;
    margin: 10px;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    border-radius: 8px;
    text-align: center;
  }
  
  .metric-card h3 {
    margin: 0;
    font-size: 2.2rem;
    color: #1e90ff;
  }
  
  .metric-card p {
    margin: 5px 0 0 0;
    font-size: 1.2rem;
    color: #ccc;
  }
  
  #layersList {
    min-height: 100px;
  }
  
  #layersList p {
    font-size: 1.15rem;
  }
  
  .loading {
    display: none;
    text-align: center;
    padding: 20px;
    color: #1e90ff;
    font-size: 1.4rem;
  }
  
  .loading.active {
    display: block;
  }
  
  .architecture-preview {
    background: rgba(20, 20, 20, 0.9);
    border: 1px solid #444;
    padding: 15px;
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 1.05rem;
    color: #aaa;
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .checkbox-group input[type="checkbox"] {
    width: 22px;
    height: 22px;
    cursor: pointer;
  }
  
  .checkbox-group label {
    font-size: 1.1rem !important;
  }
</style>

<div class="custom-container">
  <div style="text-align: center; margin-bottom: 20px;">
    <a href="/" style="display: inline-block; padding: 10px 20px; background: #444; color: #e0e0e0; text-decoration: none; border-radius: 6px; font-size: 1.1rem; margin-bottom: 15px;">‚Üê Voltar para Tela Principal</a>
  </div>
  <h1 style="text-align: center; color: #1e90ff; font-size: 2.2rem;">Modelo Personalizado LSTM - NVIDIA</h1>
  <p style="text-align: center; color: #aaa; font-size: 1.15rem;">Configure sua pr√≥pria arquitetura de rede neural para previs√£o de pre√ßos da NVIDIA (NVDA)</p>
  
  <!-- CONFIGURA√á√ÉO DE LAYERS -->
  <div class="section-title">Arquitetura do Modelo</div>
  
  <div id="layersList"></div>
  
  <div style="margin: 15px 0;">
    <button class="btn-secondary" onclick="addLayer('LSTM')" title="Adiciona camada LSTM (Long Short-Term Memory) para capturar padr√µes temporais">+ LSTM Layer</button>
    <button class="btn-secondary" onclick="addLayer('GRU')" title="Adiciona camada GRU (Gated Recurrent Unit) - mais r√°pida que LSTM">+ GRU Layer</button>
    <button class="btn-secondary" onclick="addLayer('Dense')" title="Adiciona camada densa (totalmente conectada) para transforma√ß√µes n√£o-lineares">+ Dense Layer</button>
    <button class="btn-secondary" onclick="addLayer('Dropout')" title="Adiciona Dropout para prevenir overfitting (desativa neur√¥nios aleatoriamente)">+ Dropout</button>
    <button class="btn-secondary" onclick="addLayer('LayerNorm')" title="Adiciona Layer Normalization para estabilizar o treinamento">+ Layer Normalization</button>
    <button class="btn-secondary" onclick="addLayer('BatchNorm')" title="Adiciona Batch Normalization para acelerar converg√™ncia">+ Batch Normalization</button>
  </div>
  
  <div class="architecture-preview" id="architecturePreview">
    <!-- Preview da arquitetura -->
  </div>
  
  <!-- HIPERPAR√ÇMETROS -->
  <div class="section-title">Hiperpar√¢metros de Treino</div>
  
  <div class="form-row">
    <div class="form-group">
      <label title="Algoritmo usado para ajustar os pesos da rede neural durante o treino. Adam √© o mais popular por convergir rapidamente.">Otimizador</label>
      <select id="optimizer">
        <option value="Adam">Adam</option>
        <option value="RMSprop">RMSprop</option>
        <option value="SGD">SGD (Momentum)</option>
        <option value="Adamax">Adamax</option>
        <option value="Nadam">Nadam</option>
      </select>
    </div>
    
    <div class="form-group">
      <label title="Taxa de aprendizado: controla o tamanho dos passos no ajuste dos pesos. Valores menores (0.001) s√£o mais seguros e est√°veis.">Learning Rate</label>
      <input type="number" id="learningRate" value="0.001" step="0.0001" min="0.00001">
    </div>
    
    <div class="form-group">
      <label title="Par√¢metro usado apenas pelo otimizador SGD. Ajuda a acelerar o treino e evitar oscila√ß√µes. Valores t√≠picos: 0.9">Momentum (SGD)</label>
      <input type="number" id="momentum" value="0.9" step="0.1" min="0" max="1">
    </div>
    
    <div class="form-group">
      <label title="Fun√ß√£o de perda: mede o erro entre previs√µes e valores reais. MSE penaliza erros grandes, MAE √© mais robusto a outliers.">Loss Function</label>
      <select id="loss">
        <option value="mse">MSE (Mean Squared Error)</option>
        <option value="mae">MAE (Mean Absolute Error)</option>
        <option value="huber">Huber Loss</option>
        <option value="mape">MAPE</option>
      </select>
    </div>
  </div>
  
  <div class="form-row">
    <div class="form-group">
      <label title="N√∫mero de dias passados usados para prever o futuro. Lookback maior captura mais padr√µes hist√≥ricos, mas requer mais dados.">Lookback (dias hist√≥ricos)</label>
      <input type="number" id="lookback" value="60" min="10" max="200">
    </div>
    
    <div class="form-group">
      <label title="Quantos dias no futuro queremos prever. Horizon 1 = previs√£o do pr√≥ximo dia. Valores maiores s√£o mais dif√≠ceis de prever.">Horizon (dias futuros)</label>
      <input type="number" id="horizon" value="1" min="1" max="30">
    </div>
    
    <div class="form-group">
      <label title="N√∫mero de √©pocas: quantas vezes o modelo ver√° todos os dados de treino. Mais √©pocas podem melhorar o modelo, mas podem causar overfitting.">Epochs</label>
      <input type="number" id="epochs" value="50" min="10" max="500">
    </div>
    
    <div class="form-group">
      <label title="Quantidade de exemplos processados antes de atualizar os pesos. Valores maiores s√£o mais r√°pidos, mas podem reduzir a precis√£o do treino.">Batch Size</label>
      <input type="number" id="batchSize" value="32" min="8" max="256">
    </div>
  </div>
  
  <div class="form-row">
    <div class="form-group">
      <label title="Percentual dos dados reservado para valida√ß√£o. Usado para avaliar o modelo durante o treino e evitar overfitting.">Validation Split (%)</label>
      <input type="number" id="validationSplit" value="20" min="5" max="40">
    </div>
    
    <div class="form-group">
      <label title="Quantas √©pocas esperar sem melhora antes de parar o treino automaticamente. Evita desperd√≠cio de tempo quando o modelo n√£o est√° mais aprendendo.">Early Stopping Patience</label>
      <input type="number" id="patience" value="10" min="3" max="50">
    </div>
    
    <div class="form-group checkbox-group">
      <input type="checkbox" id="reduceLR" checked title="Reduz o learning rate automaticamente quando o modelo para de melhorar, ajudando na converg√™ncia final.">
      <label for="reduceLR">Reduce LR on Plateau</label>
    </div>
  </div>
  
  <!-- A√á√ïES -->
  <div style="text-align: center; margin: 30px 0;">
    <button class="btn-primary" onclick="trainCustomModel()" title="Inicia o treinamento do modelo personalizado com a arquitetura configurada">Treinar Modelo</button>
    <button class="btn-secondary" onclick="resetConfiguration()" title="Remove todas as camadas e volta √† configura√ß√£o inicial vazia">Resetar Configura√ß√£o</button>
    <button class="btn-secondary" onclick="loadPreset('basic')" title="Carrega arquitetura b√°sica: LSTM(64) ‚Üí Dropout(0.2) ‚Üí Dense(1)">Preset: B√°sico</button>
    <button class="btn-secondary" onclick="loadPreset('advanced')" title="Carrega arquitetura avan√ßada: LSTM(128) ‚Üí LSTM(64) ‚Üí Dense(32) ‚Üí Dense(1)">Preset: Avan√ßado</button>
  </div>
  
  <!-- LOADING -->
  <div class="loading" id="loading">
    <p>Treinando modelo... Isso pode levar alguns minutos.</p>
  </div>
  
  <!-- SE√á√ÉO DE CARREGAR MODELO -->
  <div id="loadModelSection" style="background: rgba(23, 162, 184, 0.1); border: 2px solid #17a2b8; border-radius: 12px; padding: 30px; margin: 40px 0;">
    <div class="section-title" style="color: #17a2b8; border-bottom-color: #17a2b8;">üìÇ Carregar Modelo Salvo</div>
    <p style="margin-bottom: 20px; color: #b0b0b0;">Selecione os arquivos do modelo (.keras) e do scaler (.scaler) que voc√™ baixou anteriormente:</p>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
      <div>
        <label style="display: block; margin-bottom: 10px; color: #17a2b8; font-weight: 600;">üß† Arquivo do Modelo (.keras)</label>
        <input type="file" id="uploadModelFile" accept=".keras" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid #17a2b8; border-radius: 6px; color: #e0e0e0;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 10px; color: #17a2b8; font-weight: 600;">üìä Arquivo do Scaler (.scaler)</label>
        <input type="file" id="uploadScalerFile" accept=".scaler" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid #17a2b8; border-radius: 6px; color: #e0e0e0;">
      </div>
    </div>
    
    <div style="text-align: center;">
      <button onclick="loadSavedModel()" style="background: #17a2b8; color: white; border: none; padding: 15px 40px; border-radius: 8px; cursor: pointer; font-size: 1.2rem; font-weight: 600; box-shadow: 0 4px 12px rgba(23,162,184,0.3);" title="Carrega os arquivos .keras e .scaler selecionados e valida o modelo">
        ‚ö° Carregar Modelo
      </button>
    </div>
    
    <div id="loadModelStatus" style="margin-top: 20px; padding: 15px; border-radius: 8px; display: none;"></div>
    
    <!-- Painel de Predi√ß√£o (aparece ap√≥s carregar modelo) -->
    <div id="predictionPanel" style="margin-top: 30px; padding: 30px; background: rgba(40, 167, 69, 0.1); border: 2px solid #28a745; border-radius: 12px; display: none;">
      <div class="section-title" style="color: #28a745; border-bottom-color: #28a745;">üîÆ Fazer Predi√ß√µes NVIDIA</div>
      <p style="margin-bottom: 20px; color: #b0b0b0;">Use o modelo carregado para prever pre√ßos das a√ß√µes da NVIDIA (NVDA):</p>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div>
          <label style="display: block; margin-bottom: 10px; color: #28a745; font-weight: 600;">üìÖ Lookback (dias)</label>
          <input type="number" id="predLookback" value="60" min="10" max="365" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid #28a745; border-radius: 6px; color: #e0e0e0;">
        </div>
        <div>
          <label style="display: block; margin-bottom: 10px; color: #28a745; font-weight: 600;">üéØ Horizon (dias)</label>
          <input type="number" id="predHorizon" value="1" min="1" max="30" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid #28a745; border-radius: 6px; color: #e0e0e0;">
        </div>
      </div>
      
      <div style="text-align: center;">
        <button onclick="predictWithLoadedModel()" style="background: #28a745; color: white; border: none; padding: 15px 40px; border-radius: 8px; cursor: pointer; font-size: 1.2rem; font-weight: 600; box-shadow: 0 4px 12px rgba(40,167,69,0.3);" title="Usa o modelo carregado para fazer predi√ß√£o do pr√≥ximo pre√ßo da NVDA com dados reais do yfinance">
          Gerar Predi√ß√£o
        </button>
      </div>
      
      <div id="predictionResult" style="margin-top: 20px; padding: 15px; border-radius: 8px; display: none;"></div>
    </div>
  </div>
  
  <!-- RESULTADOS -->
  <div class="results-panel" id="resultsPanel">
    <div class="section-title">üìä An√°lise Completa do Modelo</div>
    
    <!-- Bot√µes de A√ß√£o -->
    <div style="display: flex; gap: 15px; margin-bottom: 30px; justify-content: center;">
      <button id="btnDownloadModel" onclick="downloadModel()" style="background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 600; display: none;" title="Baixa os arquivos .keras e .scaler do modelo treinado para seu computador">
        üíæ Baixar Modelo Treinado
      </button>
      <button onclick="document.getElementById('loadModelSection').scrollIntoView({behavior: 'smooth'})" style="background: #17a2b8; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 600;" title="Rola a p√°gina para a se√ß√£o de carregamento de modelos salvos">
        üìÇ Carregar Modelo Salvo
      </button>
    </div>
    
    <!-- Cards de M√©tricas - Grid 2x2 para principais -->
    <div style="margin-bottom: 20px;">
      <h3 style="color: #1e90ff; margin-bottom: 10px;">üìä M√©tricas de Performance</h3>
      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">
        <div class="metric-card">
          <h3 id="metricMAE">-</h3>
          <p>MAE</p>
        </div>
        <div class="metric-card">
          <h3 id="metricRMSE">-</h3>
          <p>RMSE</p>
        </div>
        <div class="metric-card">
          <h3 id="metricMAPE">-</h3>
          <p>MAPE (%)</p>
        </div>
        <div class="metric-card">
          <h3 id="metricPearson">-</h3>
          <p>Pearson</p>
        </div>
      </div>
    </div>
    
    <!-- M√©tricas de Treino -->
    <div style="margin-bottom: 30px;">
      <h3 style="color: #1e90ff; margin-bottom: 10px;">‚öôÔ∏è M√©tricas de Treino</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
        <div class="metric-card">
          <h3 id="epochsTrained">-</h3>
          <p>Epochs</p>
        </div>
        <div class="metric-card">
          <h3 id="durationTime">-</h3>
          <p>Dura√ß√£o (s)</p>
        </div>
        <div class="metric-card">
          <h3 id="ramUsed">-</h3>
          <p>RAM (MB)</p>
        </div>
      </div>
    </div>
    
    <div style="display: none;"><!-- mant√©m estrutura antiga oculta -->
    </div>
    
    <!-- Arquitetura do Modelo -->
    <div class="section-title" style="margin-top: 40px;">üèóÔ∏è Arquitetura da Rede Neural</div>
    <div style="background: #1a1a1a; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 30px; border: 1px solid #333;">
      <div id="architectureVisual"></div>
      <details style="margin-top: 20px;">
        <summary style="cursor: pointer; font-weight: bold; color: #1e90ff;">Ver Resumo Detalhado do Modelo</summary>
        <pre id="architectureText" style="background: #2a2a2a; padding: 15px; border-radius: 5px; overflow-x: auto; margin-top: 10px; font-size: 12px; color: #e0e0e0; border: 1px solid #444;"></pre>
      </details>
    </div>
    
    <!-- Hist√≥rico de Treino -->
    <div class="section-title">üìà Hist√≥rico de Treino (Loss & MAE)</div>
    <div id="chartTrainingHistory" style="margin: 0 auto 30px; height: 500px; width: 95%; max-width: 1400px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;"></div>
    
    <!-- Ajuste Temporal -->
    <div class="section-title">üìâ Ajuste Temporal (Real vs Predito)</div>
    <div id="chartTimeSeries" style="margin: 0 auto 30px; height: 500px; width: 95%; max-width: 1400px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;"></div>
    
    <!-- Dispers√£o Y Real vs Y Predito -->
    <div class="section-title">üéØ Dispers√£o: Real vs Predito</div>
    <div id="chartScatter" style="margin: 0 auto 30px; height: 500px; width: 95%; max-width: 1400px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;"></div>
    
    <!-- Distribui√ß√£o de Res√≠duos -->
    <div class="section-title">üìä Distribui√ß√£o de Res√≠duos (Erros)</div>
    <div id="chartResiduals" style="margin: 0 auto 30px; height: 500px; width: 95%; max-width: 1400px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;"></div>
    
    <!-- Histograma de Erros -->
    <div class="section-title">üìä Histograma de Erros</div>
    <div id="chartErrorHistogram" style="margin: 0 auto 30px; height: 500px; width: 95%; max-width: 1400px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;"></div>
  </div>
</div>

<script src="https://cdn.plot.ly/plotly-2.14.0.min.js"></script>
<script>
let layers = [];
let layerCounter = 0;

// Adicionar layer
function addLayer(type) {
  const layer = {
    id: layerCounter++,
    type: type
  };
  
  if (type === 'LSTM' || type === 'GRU') {
    layer.units = 64;
    layer.return_sequences = false;
    layer.bidirectional = false;
    layer.dropout = 0.0;
  } else if (type === 'Dense') {
    layer.units = 32;
    layer.activation = 'relu';
  } else if (type === 'Dropout') {
    layer.rate = 0.2;
  }
  
  layers.push(layer);
  renderLayers();
  updatePreview();
}

// Remover layer
function removeLayer(id) {
  layers = layers.filter(l => l.id !== id);
  renderLayers();
  updatePreview();
}

// Atualizar layer
function updateLayer(id, field, value) {
  const layer = layers.find(l => l.id === id);
  if (!layer) return;
  
  if (field === 'return_sequences' || field === 'bidirectional') {
    layer[field] = value;
  } else if (field === 'units' || field === 'rate') {
    layer[field] = parseFloat(value);
  } else {
    layer[field] = value;
  }
  
  updatePreview();
}

// Renderizar layers
function renderLayers() {
  const container = document.getElementById('layersList');
  
  if (layers.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 30px; font-size: 1.15rem;">Nenhuma layer adicionada. Clique nos bot√µes abaixo para come√ßar.</p>';
    return;
  }
  
  container.innerHTML = layers.map((layer, idx) => {
    let fields = '';
    
    if (layer.type === 'LSTM' || layer.type === 'GRU') {
      fields = `
        <div class="form-row">
          <div class="form-group">
            <label title="N√∫mero de neur√¥nios na camada. Mais units = mais capacidade de aprendizado, mas maior risco de overfitting e treino mais lento.">Units</label>
            <input type="number" value="${layer.units}" min="8" max="512" 
                   onchange="updateLayer(${layer.id}, 'units', this.value)">
          </div>
          <div class="form-group">
            <label title="Dropout desliga aleatoriamente neur√¥nios durante o treino para prevenir overfitting. Valores t√≠picos: 0.2 a 0.5">Dropout</label>
            <input type="number" value="${layer.dropout}" min="0" max="0.9" step="0.1"
                   onchange="updateLayer(${layer.id}, 'dropout', this.value)">
          </div>
          <div class="form-group checkbox-group">
            <input type="checkbox" id="seq_${layer.id}" ${layer.return_sequences ? 'checked' : ''}
                   onchange="updateLayer(${layer.id}, 'return_sequences', this.checked)" title="Ativado: retorna sequ√™ncia completa (necess√°rio para empilhar camadas LSTM). Desativado: retorna apenas √∫ltimo timestep.">
            <label for="seq_${layer.id}" title="Ativado: retorna sequ√™ncia completa (necess√°rio para empilhar camadas LSTM). Desativado: retorna apenas √∫ltimo timestep.">Return Sequences</label>
          </div>
          <div class="form-group checkbox-group">
            <input type="checkbox" id="bi_${layer.id}" ${layer.bidirectional ? 'checked' : ''}
                   onchange="updateLayer(${layer.id}, 'bidirectional', this.checked)" title="Processa a sequ√™ncia em ambas dire√ß√µes (passado‚Üífuturo e futuro‚Üípassado). Dobra o n√∫mero de par√¢metros mas pode melhorar a performance.">
            <label for="bi_${layer.id}" title="Processa a sequ√™ncia em ambas dire√ß√µes (passado‚Üífuturo e futuro‚Üípassado). Dobra o n√∫mero de par√¢metros mas pode melhorar a performance.">Bidirectional</label>
          </div>
        </div>
      `;
    } else if (layer.type === 'Dense') {
      fields = `
        <div class="form-row">
          <div class="form-group">
            <label title="N√∫mero de neur√¥nios na camada totalmente conectada.">Units</label>
            <input type="number" value="${layer.units}" min="1" max="512"
                   onchange="updateLayer(${layer.id}, 'units', this.value)">
          </div>
          <div class="form-group">
            <label title="Fun√ß√£o de ativa√ß√£o: ReLU √© padr√£o para camadas intermedi√°rias, Linear para camada final de regress√£o.">Activation</label>
            <select onchange="updateLayer(${layer.id}, 'activation', this.value)">
              <option value="relu" ${layer.activation === 'relu' ? 'selected' : ''}>ReLU</option>
              <option value="tanh" ${layer.activation === 'tanh' ? 'selected' : ''}>Tanh</option>
              <option value="sigmoid" ${layer.activation === 'sigmoid' ? 'selected' : ''}>Sigmoid</option>
              <option value="linear" ${layer.activation === 'linear' ? 'selected' : ''}>Linear</option>
              <option value="none" ${layer.activation === 'none' ? 'selected' : ''}>None</option>
            </select>
          </div>
        </div>
      `;
    } else if (layer.type === 'Dropout') {
      fields = `
        <div class="form-row">
          <div class="form-group">
            <label title="Percentual de neur√¥nios desligados aleatoriamente durante o treino. Valores t√≠picos: 0.2 a 0.5">Dropout Rate</label>
            <input type="number" value="${layer.rate}" min="0.1" max="0.9" step="0.1"
                   onchange="updateLayer(${layer.id}, 'rate', this.value)">
          </div>
        </div>
      `;
    }
    
    return `
      <div class="layer-card">
        <h4>
          <span>Layer ${idx + 1}: ${layer.type}</span>
          <button class="remove-layer" onclick="removeLayer(${layer.id})">Remover</button>
        </h4>
        ${fields}
      </div>
    `;
  }).join('');
}

// Preview da arquitetura
function updatePreview() {
  const preview = document.getElementById('architecturePreview');
  
  if (layers.length === 0) {
    preview.innerHTML = 'Nenhuma layer configurada';
    return;
  }
  
  let text = 'Sequential([\n';
  text += '  Input(shape=(lookback, 1)),\n';
  
  layers.forEach((layer, idx) => {
    if (layer.type === 'LSTM' || layer.type === 'GRU') {
      const prefix = layer.bidirectional ? 'Bidirectional(' : '';
      const suffix = layer.bidirectional ? ')' : '';
      text += `  ${prefix}${layer.type}(${layer.units}, return_sequences=${layer.return_sequences}, dropout=${layer.dropout})${suffix},\n`;
    } else if (layer.type === 'Dense') {
      const act = layer.activation !== 'none' ? `, activation='${layer.activation}'` : '';
      text += `  Dense(${layer.units}${act}),\n`;
    } else if (layer.type === 'Dropout') {
      text += `  Dropout(${layer.rate}),\n`;
    } else if (layer.type === 'LayerNorm') {
      text += `  LayerNormalization(),\n`;
    } else if (layer.type === 'BatchNorm') {
      text += `  BatchNormalization(),\n`;
    }
  });
  
  text += '])';
  preview.textContent = text;
}

// Treinar modelo
async function trainCustomModel() {
  if (layers.length === 0) {
    alert('Adicione pelo menos uma layer antes de treinar!');
    return;
  }
  
  // Validar que tem output layer (Dense com 1 unit)
  const hasOutput = layers.some(l => l.type === 'Dense' && l.units === 1);
  if (!hasOutput) {
    layers.push({
      id: layerCounter++,
      type: 'Dense',
      units: 1,
      activation: 'linear'
    });
    renderLayers();
    updatePreview();
  }
  
  const config = {
    layers: layers.map(l => {
      const cfg = { type: l.type };
      if (l.units !== undefined) cfg.units = l.units;
      if (l.return_sequences !== undefined) cfg.return_sequences = l.return_sequences;
      if (l.bidirectional !== undefined) cfg.bidirectional = l.bidirectional;
      if (l.dropout !== undefined) cfg.dropout = l.dropout;
      if (l.activation !== undefined && l.activation !== 'none') cfg.activation = l.activation;
      if (l.rate !== undefined) cfg.rate = l.rate;
      return cfg;
    }),
    optimizer: {
      name: document.getElementById('optimizer').value,
      learning_rate: parseFloat(document.getElementById('learningRate').value),
      momentum: parseFloat(document.getElementById('momentum').value)
    },
    loss: document.getElementById('loss').value
  };
  
  const payload = {
    ticker: 'NVDA',
    config: config,
    lookback: parseInt(document.getElementById('lookback').value),
    horizon: parseInt(document.getElementById('horizon').value),
    epochs: parseInt(document.getElementById('epochs').value),
    batch_size: parseInt(document.getElementById('batchSize').value),
    validation_split: parseFloat(document.getElementById('validationSplit').value) / 100,
    patience: parseInt(document.getElementById('patience').value),
    reduce_lr: document.getElementById('reduceLR').checked
  };
  
  document.getElementById('loading').classList.add('active');
  document.getElementById('resultsPanel').style.display = 'none';
  
  try {
    const response = await fetch('/api/train-custom', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Erro no treino');
    }
    
    // Exibir resultados
    // Atualizar m√©tricas
    document.getElementById('metricMAE').textContent = data.metrics.mae.toFixed(4);
    document.getElementById('metricRMSE').textContent = data.metrics.rmse.toFixed(4);
    document.getElementById('metricMAPE').textContent = data.metrics.mape.toFixed(2);
    document.getElementById('metricPearson').textContent = (data.metrics.pearson_corr ?? 0).toFixed(4);
    document.getElementById('epochsTrained').textContent = data.epochs_trained;
    document.getElementById('durationTime').textContent = data.resources.duration_sec.toFixed(2);
    document.getElementById('ramUsed').textContent = data.resources.ram_used_mb.toFixed(1);
    
    // Plotar todos os gr√°ficos
    plotTrainingHistory(data.history);
    plotArchitecture(data.architecture);
    plotTimeSeries(data.predictions);
    plotScatter(data.predictions);
    plotResiduals(data.predictions);
    plotErrorHistogram(data.predictions);
    
    // Habilitar download
    currentModelName = data.model_name;
    document.getElementById('btnDownloadModel').style.display = 'inline-block';
    
    document.getElementById('resultsPanel').style.display = 'block';
    alert('‚úÖ Modelo treinado com sucesso!');
    
  } catch (error) {
    alert('‚ùå Erro ao treinar: ' + error.message);
  } finally {
    document.getElementById('loading').classList.remove('active');
  }
}

// ========== FUN√á√ïES DE PLOTAGEM ==========

// 1. Arquitetura do Modelo
function plotArchitecture(architecture) {
  // Descri√ß√µes detalhadas para cada tipo de layer
  const layerDescriptions = {
    'LSTM': {
      icon: 'üîÑ',
      title: 'Long Short-Term Memory',
      desc: 'Camada recorrente que aprende depend√™ncias temporais de longo prazo. Possui gates (port√µes) para controlar fluxo de informa√ß√£o: forget gate, input gate e output gate.',
      use: 'Ideal para s√©ries temporais, texto e dados sequenciais'
    },
    'GRU': {
      icon: '‚ö°',
      title: 'Gated Recurrent Unit',
      desc: 'Similar ao LSTM mas mais simples e r√°pida. Possui apenas 2 gates (update e reset) em vez de 3, resultando em menos par√¢metros.',
      use: 'Boa alternativa ao LSTM quando velocidade √© cr√≠tica'
    },
    'Dense': {
      icon: 'üéØ',
      title: 'Fully Connected Layer',
      desc: 'Camada totalmente conectada onde cada neur√¥nio recebe entrada de todos os neur√¥nios da camada anterior. Realiza transforma√ß√£o linear seguida de ativa√ß√£o.',
      use: 'Camada final para regress√£o/classifica√ß√£o'
    },
    'Dropout': {
      icon: 'üé≤',
      title: 'Regulariza√ß√£o por Dropout',
      desc: 'Durante treino, desativa aleatoriamente uma fra√ß√£o dos neur√¥nios (definida por "rate"). Previne overfitting ao for√ßar a rede a aprender features redundantes.',
      use: 'Regulariza√ß√£o para evitar sobreajuste'
    },
    'LayerNormalization': {
      icon: 'üìä',
      title: 'Layer Normalization',
      desc: 'Normaliza as ativa√ß√µes ao longo das features (dimens√µes) para cada amostra. Estabiliza e acelera o treino, especialmente em RNNs.',
      use: 'Estabiliza√ß√£o de treino em redes profundas'
    },
    'BatchNormalization': {
      icon: 'üìà',
      title: 'Batch Normalization',
      desc: 'Normaliza as ativa√ß√µes ao longo do batch (mini-lote). Reduz "Internal Covariate Shift" permitindo learning rates maiores.',
      use: 'Acelera converg√™ncia e reduz sensibilidade √† inicializa√ß√£o'
    }
  };
  
  let html = '<div style="font-family: monospace;">';
  html += `<div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px;">`;
  html += `<strong>Total de Par√¢metros:</strong> ${architecture.total_params.toLocaleString()}<br>`;
  html += `<strong>Par√¢metros Trein√°veis:</strong> ${architecture.trainable_params.toLocaleString()}`;
  html += `</div>`;
  
  html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
  architecture.summary.forEach((layer, idx) => {
    const color = layer.type.includes('LSTM') || layer.type.includes('GRU') ? '#1e90ff' : 
                  layer.type.includes('Dense') ? '#4CAF50' : 
                  layer.type.includes('Dropout') ? '#ff9800' : 
                  layer.type.includes('Normalization') ? '#9c27b0' : '#9e9e9e';
    
    const info = layerDescriptions[layer.type] || { icon: 'üîπ', title: layer.type, desc: 'Camada customizada', use: '' };
    
    const tooltipContent = `${info.icon} ${info.title}\\n\\n${info.desc}\\n\\n‚úì ${info.use}`;
    
    html += `
      <div style="display: flex; align-items: center; padding: 15px; background: white; border-left: 4px solid ${color}; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: help; transition: all 0.2s;" 
           title="${tooltipContent}"
           onmouseover="this.style.transform='translateX(5px)'; this.style.boxShadow='0 3px 12px rgba(0,0,0,0.2)';"
           onmouseout="this.style.transform='translateX(0)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)';">
        <div style="font-size: 32px; margin-right: 15px;">${info.icon}</div>
        <div style="flex: 1;">
          <strong style="color: ${color}; font-size: 16px;">${layer.type}</strong>
          ${layer.units ? `<span style="color: #666; font-weight: bold;"> (${layer.units} units)</span>` : ''}
          <br>
          <small style="color: #999;">
            Shape: ${layer.output_shape} | 
            Params: ${layer.params.toLocaleString()}
            ${layer.activation ? ` | Activation: <span style="color: ${color}; font-weight: bold;">${layer.activation}</span>` : ''}
          </small>
          <br>
          <small style="color: #666; font-style: italic;">${info.use}</small>
        </div>
        <div style="font-size: 24px; color: #ddd; margin-left: 10px;">‚Üí</div>
      </div>
    `;
  });
  html += '</div></div>';
  
  document.getElementById('architectureVisual').innerHTML = html;
  document.getElementById('architectureText').textContent = architecture.text;
}

// 2. Hist√≥rico de Treino
function plotTrainingHistory(history) {
  const epochs = history.loss.map((_, i) => i + 1);
  
  const traces = [
    {
      x: epochs,
      y: history.loss,
      name: 'Training Loss',
      type: 'scatter',
      mode: 'lines+markers',
      line: { color: '#ff6b6b', width: 3 },
      marker: { size: 8, line: { width: 2, color: '#1a1a1a' } }
    },
    {
      x: epochs,
      y: history.val_loss,
      name: 'Validation Loss',
      type: 'scatter',
      mode: 'lines+markers',
      line: { color: '#4ecdc4', width: 3 },
      marker: { size: 8, line: { width: 2, color: '#1a1a1a' } }
    }
  ];
  
  const layout = {
    title: { 
      text: 'Loss ao Longo das √âpocas',
      font: { color: '#e0e0e0', size: 18 }
    },
    xaxis: { 
      title: { text: '√âpoca', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    yaxis: { 
      title: { text: 'Loss (MSE)', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    paper_bgcolor: '#1a1a1a',
    plot_bgcolor: '#1a1a1a',
    font: { family: 'Segoe UI, Arial', size: 12, color: '#e0e0e0' },
    showlegend: true,
    legend: { 
      x: 0.02, 
      y: 0.98,
      bgcolor: 'rgba(30,30,30,0.8)',
      bordercolor: '#1e90ff',
      borderwidth: 1,
      font: { color: '#e0e0e0' }
    },
    hovermode: 'x unified',
    hoverlabel: { bgcolor: '#2a2a2a', font: { color: '#e0e0e0' } },
    margin: { l: 60, r: 20, t: 60, b: 60 }
  };
  
  const config = { responsive: true, displayModeBar: false };
  Plotly.newPlot('chartTrainingHistory', traces, layout, config);
}

// 3. S√©rie Temporal (Real vs Predito)
function plotTimeSeries(predictions) {
  const indices = predictions.y_true.map((_, i) => i);
  const splitIdx = predictions.split_index;
  
  const traces = [
    {
      x: indices,
      y: predictions.y_true,
      name: 'Real',
      type: 'scatter',
      mode: 'lines',
      line: { color: '#1e90ff', width: 2.5 }
    },
    {
      x: indices,
      y: predictions.y_pred,
      name: 'Predito',
      type: 'scatter',
      mode: 'lines',
      line: { color: '#ff6b6b', width: 2, dash: 'dot' }
    }
  ];
  
  const layout = {
    title: { 
      text: 'Valores Reais vs Preditos ao Longo do Tempo',
      font: { color: '#e0e0e0', size: 18 }
    },
    xaxis: { 
      title: { text: '√çndice Temporal', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    yaxis: { 
      title: { text: 'Pre√ßo', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    paper_bgcolor: '#1a1a1a',
    plot_bgcolor: '#1a1a1a',
    font: { family: 'Segoe UI, Arial', size: 12, color: '#e0e0e0' },
    showlegend: true,
    legend: { 
      x: 0.02, 
      y: 0.98,
      bgcolor: 'rgba(30,30,30,0.8)',
      bordercolor: '#1e90ff',
      borderwidth: 1,
      font: { color: '#e0e0e0' }
    },
    hovermode: 'x unified',
    hoverlabel: { bgcolor: '#2a2a2a', font: { color: '#e0e0e0' } },
    margin: { l: 60, r: 20, t: 60, b: 60 },
    shapes: [
      {
        type: 'line',
        x0: splitIdx,
        y0: 0,
        x1: splitIdx,
        yref: 'paper',
        y1: 1,
        line: {
          color: '#4CAF50',
          width: 2,
          dash: 'dash'
        }
      }
    ],
    annotations: [
      {
        x: splitIdx,
        y: 1,
        yref: 'paper',
        text: '‚Üê Treino | Valida√ß√£o ‚Üí',
        showarrow: false,
        yanchor: 'bottom',
        font: { color: '#4CAF50', size: 11, weight: 'bold' }
      }
    ]
  };
  
  const config = { responsive: true, displayModeBar: false };
  Plotly.newPlot('chartTimeSeries', traces, layout, config);
}

// 4. Gr√°fico de Dispers√£o
function plotScatter(predictions) {
  const minVal = Math.min(...predictions.y_true, ...predictions.y_pred);
  const maxVal = Math.max(...predictions.y_true, ...predictions.y_pred);
  
  // Calcular R¬≤
  const yTrue = predictions.y_true;
  const yPred = predictions.y_pred;
  const meanTrue = yTrue.reduce((a, b) => a + b, 0) / yTrue.length;
  const ssTotal = yTrue.reduce((sum, val) => sum + Math.pow(val - meanTrue, 2), 0);
  const ssRes = yTrue.reduce((sum, val, i) => sum + Math.pow(val - yPred[i], 2), 0);
  const r2 = 1 - (ssRes / ssTotal);
  
  const traces = [
    {
      x: predictions.y_true,
      y: predictions.y_pred,
      mode: 'markers',
      type: 'scatter',
      name: 'Predi√ß√µes',
      marker: {
        size: 6,
        color: predictions.y_true,
        colorscale: 'Electric',
        showscale: true,
        colorbar: { 
          title: { text: 'Valor Real', font: { color: '#e0e0e0' } },
          tickfont: { color: '#b0b0b0' },
          bgcolor: '#1a1a1a',
          bordercolor: '#1e90ff',
          borderwidth: 1,
          outlinecolor: '#1e90ff',
          outlinewidth: 0
        },
        opacity: 0.7,
        line: { width: 0.5, color: 'rgba(255,255,255,0.2)' }
      },
      hovertemplate: '<b>Real:</b> %{x:.2f}<br><b>Predito:</b> %{y:.2f}<br><b>Erro:</b> %{customdata:.2f}<extra></extra>',
      customdata: yTrue.map((val, i) => val - yPred[i])
    },
    {
      x: [minVal, maxVal],
      y: [minVal, maxVal],
      mode: 'lines',
      type: 'scatter',
      name: 'Ideal (y=x)',
      line: { color: '#4CAF50', width: 3, dash: 'dash' },
      hoverinfo: 'skip'
    }
  ];
  
  const layout = {
    title: { 
      text: 'Dispers√£o: Valores Preditos vs Valores Reais',
      font: { color: '#e0e0e0', size: 18 }
    },
    xaxis: { 
      title: { text: 'Valor Real', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    yaxis: { 
      title: { text: 'Valor Predito', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    paper_bgcolor: '#1a1a1a',
    plot_bgcolor: '#1a1a1a',
    font: { family: 'Segoe UI, Arial', size: 12, color: '#e0e0e0' },
    showlegend: true,
    legend: { 
      x: 0.02, 
      y: 0.98,
      bgcolor: 'rgba(30,30,30,0.8)',
      bordercolor: '#1e90ff',
      borderwidth: 1,
      font: { color: '#e0e0e0' }
    },
    hovermode: 'closest',
    hoverlabel: { bgcolor: '#2a2a2a', font: { color: '#e0e0e0', size: 13 } },
    margin: { l: 60, r: 20, t: 60, b: 60 },
    annotations: [
      {
        x: 0.02,
        y: 0.88,
        xref: 'paper',
        yref: 'paper',
        text: `<b>R¬≤ = ${r2.toFixed(4)}</b>`,
        showarrow: false,
        font: { size: 16, color: '#1e90ff', family: 'monospace' },
        bgcolor: 'rgba(30,30,30,0.9)',
        bordercolor: '#1e90ff',
        borderwidth: 2,
        borderpad: 8
      }
    ]
  };
  
  const config = { responsive: true, displayModeBar: false };
  Plotly.newPlot('chartScatter', traces, layout, config);
}

// 5. Res√≠duos ao Longo do Tempo
function plotResiduals(predictions) {
  const indices = predictions.residuals.map((_, i) => i);
  
  const traces = [
    {
      x: indices,
      y: predictions.residuals,
      type: 'scatter',
      mode: 'markers',
      name: 'Res√≠duos',
      marker: {
        size: 5,
        color: predictions.residuals.map(r => r >= 0 ? '#4CAF50' : '#ff6b6b'),
        opacity: 0.7,
        line: { width: 0 }
      },
      showlegend: false
    },
    {
      x: indices,
      y: Array(indices.length).fill(0),
      type: 'scatter',
      mode: 'lines',
      name: 'Linha Zero',
      line: { color: '#888888', width: 2, dash: 'dash' },
      hoverinfo: 'skip'
    }
  ];
  
  const layout = {
    title: { 
      text: 'Res√≠duos (Erro = Real - Predito)',
      font: { color: '#e0e0e0', size: 18 }
    },
    xaxis: { 
      title: { text: '√çndice', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    yaxis: { 
      title: { text: 'Res√≠duo', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: true,
      zerolinecolor: '#888888',
      zerolinewidth: 2
    },
    paper_bgcolor: '#1a1a1a',
    plot_bgcolor: '#1a1a1a',
    font: { family: 'Segoe UI, Arial', size: 12, color: '#e0e0e0' },
    showlegend: true,
    legend: { 
      x: 0.02, 
      y: 0.98,
      bgcolor: 'rgba(30,30,30,0.8)',
      bordercolor: '#1e90ff',
      borderwidth: 1,
      font: { color: '#e0e0e0' }
    },
    hovermode: 'closest',
    hoverlabel: { bgcolor: '#2a2a2a', font: { color: '#e0e0e0' } },
    margin: { l: 60, r: 20, t: 60, b: 60 }
  };
  
  const config = { responsive: true, displayModeBar: false };
  Plotly.newPlot('chartResiduals', traces, layout, config);
}

// 6. Histograma de Erros
function plotErrorHistogram(predictions) {
  const traces = [
    {
      x: predictions.residuals,
      type: 'histogram',
      name: 'Distribui√ß√£o de Erros',
      marker: {
        color: '#1e90ff',
        line: { color: '#1a1a1a', width: 2 }
      },
      nbinsx: 40,
      opacity: 0.8
    }
  ];
  
  const layout = {
    title: { 
      text: 'Distribui√ß√£o de Erros (Res√≠duos)',
      font: { color: '#e0e0e0', size: 18 }
    },
    xaxis: { 
      title: { text: 'Erro (Real - Predito)', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: true,
      zerolinecolor: '#4CAF50',
      zerolinewidth: 2
    },
    yaxis: { 
      title: { text: 'Frequ√™ncia', font: { color: '#b0b0b0' } },
      gridcolor: 'rgba(255,255,255,0.1)',
      showgrid: false,
      color: '#b0b0b0',
      zeroline: false
    },
    paper_bgcolor: '#1a1a1a',
    plot_bgcolor: '#1a1a1a',
    font: { family: 'Segoe UI, Arial', size: 12, color: '#e0e0e0' },
    showlegend: false,
    bargap: 0.05,
    hoverlabel: { bgcolor: '#2a2a2a', font: { color: '#e0e0e0' } },
    margin: { l: 60, r: 20, t: 60, b: 60 }
  };
  
  const config = { responsive: true, displayModeBar: false };
  Plotly.newPlot('chartErrorHistogram', traces, layout, config);
}

// Reset
function resetConfiguration() {
  layers = [];
  layerCounter = 0;
  renderLayers();
  updatePreview();
  document.getElementById('resultsPanel').style.display = 'none';
}

// Presets
function loadPreset(type) {
  resetConfiguration();
  
  if (type === 'basic') {
    addLayer('LSTM');
    updateLayer(layers[0].id, 'units', 64);
    updateLayer(layers[0].id, 'return_sequences', false);
    addLayer('Dense');
    updateLayer(layers[1].id, 'units', 32);
    addLayer('Dense');
    updateLayer(layers[2].id, 'units', 1);
    updateLayer(layers[2].id, 'activation', 'linear');
  } else if (type === 'advanced') {
    addLayer('LSTM');
    updateLayer(layers[0].id, 'units', 128);
    updateLayer(layers[0].id, 'return_sequences', true);
    updateLayer(layers[0].id, 'bidirectional', true);
    addLayer('Dropout');
    addLayer('LSTM');
    updateLayer(layers[2].id, 'units', 64);
    updateLayer(layers[2].id, 'return_sequences', false);
    addLayer('LayerNorm');
    addLayer('Dense');
    updateLayer(layers[4].id, 'units', 32);
    addLayer('Dropout');
    addLayer('Dense');
    updateLayer(layers[6].id, 'units', 1);
    updateLayer(layers[6].id, 'activation', 'linear');
  }
  
  renderLayers();
  updatePreview();
}

// Inicializar com preset b√°sico
document.addEventListener('DOMContentLoaded', () => {
  loadPreset('basic');
});

// DOWNLOAD DE MODELO
let currentModelName = null;

async function downloadModel() {
  if (!currentModelName) {
    alert('Nenhum modelo dispon√≠vel para download!');
    return;
  }
  
  try {
    // Baixar modelo (.keras)
    const modelUrl = `/api/download-model?model_name=${currentModelName}&file_type=model`;
    await downloadFile(modelUrl, `${currentModelName}.keras`);
    
    // Aguardar 1s e baixar scaler (.scaler)
    await new Promise(resolve => setTimeout(resolve, 1000));
    const scalerUrl = `/api/download-model?model_name=${currentModelName}&file_type=scaler`;
    await downloadFile(scalerUrl, `${currentModelName}.scaler`);
    
    alert('‚úÖ Download conclu√≠do! Verifique seus arquivos baixados.');
  } catch (error) {
    alert('‚ùå Erro no download: ' + error.message);
  }
}

async function downloadFile(url, filename) {
  const response = await fetch(url);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Erro no download');
  }
  
  const blob = await response.blob();
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(link.href);
}

// CARREGAR MODELO SALVO
async function loadSavedModel() {
  const modelFile = document.getElementById('uploadModelFile').files[0];
  const scalerFile = document.getElementById('uploadScalerFile').files[0];
  const statusDiv = document.getElementById('loadModelStatus');
  
  if (!modelFile || !scalerFile) {
    statusDiv.style.display = 'block';
    statusDiv.style.background = 'rgba(220, 53, 69, 0.2)';
    statusDiv.style.border = '1px solid #dc3545';
    statusDiv.style.color = '#dc3545';
    statusDiv.innerHTML = '‚ùå Selecione ambos os arquivos (modelo e scaler)!';
    return;
  }
  
  const formData = new FormData();
  formData.append('model_file', modelFile);
  formData.append('scaler_file', scalerFile);
  
  statusDiv.style.display = 'block';
  statusDiv.style.background = 'rgba(23, 162, 184, 0.2)';
  statusDiv.style.border = '1px solid #17a2b8';
  statusDiv.style.color = '#17a2b8';
  statusDiv.innerHTML = '‚è≥ Carregando modelo...';
  
  try {
    const response = await fetch('/api/load-model', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (!response.ok || result.error) {
      // Mostrar erro detalhado
      statusDiv.style.background = 'rgba(220, 53, 69, 0.2)';
      statusDiv.style.border = '1px solid #dc3545';
      statusDiv.style.color = '#dc3545';
      
      let errorMsg = `‚ùå <b>Erro ao carregar modelo:</b><br>${result.error || 'Erro desconhecido'}`;
      if (result.traceback) {
        errorMsg += `<br><br><details><summary>Ver detalhes t√©cnicos</summary><pre style="font-size: 10px; overflow-x: auto;">${result.traceback}</pre></details>`;
      }
      statusDiv.innerHTML = errorMsg;
      return;
    }
    
    if (result.status === 'success') {
      statusDiv.style.background = 'rgba(40, 167, 69, 0.2)';
      statusDiv.style.border = '1px solid #28a745';
      statusDiv.style.color = '#28a745';
      statusDiv.innerHTML = `
        ‚úÖ <b>Modelo carregado com sucesso!</b><br>
        üìä Nome: ${result.model_name}<br>
        üß† Camadas: ${result.layers || 'N/A'}<br>
        üìà Par√¢metros: ${result.params ? result.params.toLocaleString() : 'N/A'}<br><br>
        Agora voc√™ pode usar este modelo para fazer predi√ß√µes!
      `;
      
      currentModelName = result.model_name;
      document.getElementById('btnDownloadModel').style.display = 'inline-block';
      
      // Mostrar painel de predi√ß√£o
      document.getElementById('predictionPanel').style.display = 'block';
      setTimeout(() => {
        document.getElementById('predictionPanel').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 500);
    }
  } catch (error) {
    statusDiv.style.background = 'rgba(220, 53, 69, 0.2)';
    statusDiv.style.border = '1px solid #dc3545';
    statusDiv.style.color = '#dc3545';
    statusDiv.innerHTML = `‚ùå Erro ao carregar modelo: ${error.message}`;
  }
}

// FAZER PREDI√á√ÉO COM MODELO CARREGADO
async function predictWithLoadedModel() {
  if (!currentModelName) {
    alert('Nenhum modelo carregado!');
    return;
  }
  
  const ticker = 'NVDA';  // Sempre NVIDIA
  const lookback = parseInt(document.getElementById('predLookback').value);
  const horizon = parseInt(document.getElementById('predHorizon').value);
  const resultDiv = document.getElementById('predictionResult');
  
  resultDiv.style.display = 'block';
  resultDiv.style.background = 'rgba(23, 162, 184, 0.2)';
  resultDiv.style.border = '1px solid #17a2b8';
  resultDiv.style.color = '#17a2b8';
  resultDiv.innerHTML = '‚è≥ Gerando predi√ß√£o...';
  
  try {
    const response = await fetch('/api/predict-loaded-model', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model_name: currentModelName,
        ticker: ticker,
        lookback: lookback,
        horizon: horizon
      })
    });
    
    const result = await response.json();
    
    if (!response.ok || result.error) {
      resultDiv.style.background = 'rgba(220, 53, 69, 0.2)';
      resultDiv.style.border = '1px solid #dc3545';
      resultDiv.style.color = '#dc3545';
      resultDiv.innerHTML = `‚ùå <b>Erro:</b> ${result.error || 'Erro desconhecido'}`;
      return;
    }
    
    // Mostrar resultado
    resultDiv.style.background = 'rgba(40, 167, 69, 0.2)';
    resultDiv.style.border = '1px solid #28a745';
    resultDiv.style.color = '#28a745';
    
    const predDate = new Date();
    predDate.setDate(predDate.getDate() + horizon);
    
    resultDiv.innerHTML = `
      ‚úÖ <b>Predi√ß√£o NVIDIA Gerada com Sucesso!</b><br><br>
      üìä <b>Ticker:</b> NVDA (NVIDIA Corporation)<br>
      üìÖ <b>Data da Predi√ß√£o:</b> ${predDate.toLocaleDateString('pt-BR')}<br>
      üíµ <b>Pre√ßo Atual:</b> $${result.current_price ? result.current_price.toFixed(2) : 'N/A'}<br>
      üéØ <b>Pre√ßo Previsto (${horizon}d):</b> <span style="font-size: 1.3em; font-weight: bold; color: #28a745;">$${result.predicted_price.toFixed(2)}</span><br>
      ${result.change_percent !== undefined ? `üìà <b>Varia√ß√£o Esperada:</b> <span style="color: ${result.change_percent >= 0 ? '#28a745' : '#dc3545'};">${result.change_percent >= 0 ? '+' : ''}${result.change_percent.toFixed(2)}%</span><br>` : ''}
      üî¢ <b>Intervalo de Confian√ßa:</b> $${result.lower_bound ? result.lower_bound.toFixed(2) : 'N/A'} - $${result.upper_bound ? result.upper_bound.toFixed(2) : 'N/A'}<br>
    `;
  } catch (error) {
    resultDiv.style.background = 'rgba(220, 53, 69, 0.2)';
    resultDiv.style.border = '1px solid #dc3545';
    resultDiv.style.color = '#dc3545';
    resultDiv.innerHTML = `‚ùå Erro ao gerar predi√ß√£o: ${error.message}`;
  }
}
</script>

{% endblock %}
